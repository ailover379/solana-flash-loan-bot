# Flash Loan Bot State (state.rs)

```rust
use anchor_lang::prelude::*;

#[account]
#[derive(InitSpace)]
pub struct FlashLoanPool {
    /// Authority who can update pool settings
    pub authority: Pubkey,
    /// Mint of the token this pool supports
    pub mint: Pubkey,
    /// Vault that holds the liquidity
    pub vault: Pubkey,
    /// Fee in basis points (100 = 1%)
    pub fee_bps: u16,
    /// Beneficiary address for profits
    pub beneficiary: Pubkey,
    /// Pool bump seed
    pub bump: u8,
    /// Emergency pause state
    pub is_paused: bool,
    /// Total fees collected
    pub total_fees_collected: u64,
    /// Total volume processed
    pub total_volume: u64,
    /// Number of flash loans executed
    pub loan_count: u64,
    /// Accumulated profit for beneficiary
    pub accumulated_profit: u64,
    /// Minimum profit threshold in lamports
    pub min_profit_threshold: u64,
    /// Maximum loan amount allowed
    pub max_loan_amount: u64,
    /// Slippage tolerance in basis points
    pub slippage_tolerance: u16,
    /// Reserved space for future updates
    pub reserved: [u8; 64],
}

impl FlashLoanPool {
    pub const INIT_SPACE: usize = 8 + // discriminator
        32 + // authority
        32 + // mint
        32 + // vault
        2 +  // fee_bps
        32 + // beneficiary
        1 +  // bump
        1 +  // is_paused
        8 +  // total_fees_collected
        8 +  // total_volume
        8 +  // loan_count
        8 +  // accumulated_profit
        8 +  // min_profit_threshold
        8 +  // max_loan_amount
        2 +  // slippage_tolerance
        64;  // reserved

    pub fn calculate_fee(&self, amount: u64) -> u64 {
        amount
            .checked_mul(self.fee_bps as u64)
            .unwrap()
            .checked_div(10000)
            .unwrap()
    }

    pub fn update_stats(&mut self, amount: u64, profit: u64) {
        self.total_volume = self.total_volume.saturating_add(amount);
        self.loan_count = self.loan_count.saturating_add(1);
        self.accumulated_profit = self.accumulated_profit.saturating_add(profit);
    }
}

#[account]
#[derive(InitSpace)]
pub struct UserStats {
    /// User's public key
    pub user: Pubkey,
    /// Total loans taken by user
    pub total_loans: u64,
    /// Total volume by user
    pub total_volume: u64,
    /// Total profit generated by user
    pub total_profit: u64,
    /// Last loan timestamp
    pub last_loan_timestamp: i64,
    /// User's success rate (loans that generated profit)
    pub success_rate: u16, // in basis points
    /// Average profit per successful loan
    pub avg_profit: u64,
    /// Reserved space for future updates
    pub reserved: [u8; 32],
}

impl UserStats {
    pub const INIT_SPACE: usize = 8 + // discriminator
        32 + // user
        8 +  // total_loans
        8 +  // total_volume
        8 +  // total_profit
        8 +  // last_loan_timestamp
        2 +  // success_rate
        8 +  // avg_profit
        32;  // reserved

    pub fn update_loan_stats(&mut self, amount: u64, profit: u64, clock: &Clock) {
        self.total_loans = self.total_loans.saturating_add(1);
        self.total_volume = self.total_volume.saturating_add(amount);
        
        if profit > 0 {
            self.total_profit = self.total_profit.saturating_add(profit);
            // Update average profit
            let successful_loans = self.calculate_successful_loans();
            if successful_loans > 0 {
                self.avg_profit = self.total_profit / successful_loans;
            }
        }
        
        self.last_loan_timestamp = clock.unix_timestamp;
        self.update_success_rate();
    }

    fn calculate_successful_loans(&self) -> u64 {
        // Estimate successful loans based on total profit > 0
        if self.total_profit > 0 && self.avg_profit > 0 {
            self.total_profit / self.avg_profit.max(1)
        } else {
            0
        }
    }

    fn update_success_rate(&mut self) {
        if self.total_loans > 0 {
            let successful_loans = self.calculate_successful_loans();
            self.success_rate = ((successful_loans * 10000) / self.total_loans) as u16;
        }
    }
}

#[account]
#[derive(InitSpace)]
pub struct ArbitrageConfig {
    /// Configuration authority
    pub authority: Pubkey,
    /// Supported DEXs configuration
    pub supported_dexs: [Pubkey; 8], // Support for up to 8 DEXs
    /// DEX fees in basis points
    pub dex_fees: [u16; 8],
    /// Priority fee configuration
    pub priority_fee: u64,
    /// Compute unit limit
    pub compute_unit_limit: u32,
    /// Global pause state
    pub global_pause: bool,
    /// Maintenance mode
    pub maintenance_mode: bool,
    /// Reserved space
    pub reserved: [u8; 128],
}

impl ArbitrageConfig {
    pub const INIT_SPACE: usize = 8 + // discriminator
        32 + // authority
        256 + // supported_dexs (32 * 8)
        16 +  // dex_fees (2 * 8)
        8 +   // priority_fee
        4 +   // compute_unit_limit
        1 +   // global_pause
        1 +   // maintenance_mode
        128;  // reserved
}
```